# 1. Introduction

The SecureSensorNode project is a complete end-to-end system designed to demonstrate how a modern engineer can build a modular, secure, and efficient embedded solution — with real hardware, real protocols, and real design decisions.

At its core, the system consists of:
- a **client node**, implemented on an STM32 microcontroller (Nucleo-F401RE board), tasked with acquiring, encrypting and sending environmental data from a BMP280 (pressure and temperature digital sensor);
- a **server**, written in Python, responsible for receiving, decrypting, and exposing those data via a RESTful API.

The communication between the two platforms happens via UART — a simple serial protocol that intentionally lacks any native encryption: this gives us the opportunity to implement **application-layer security**, encrypting and hashing data directly on the microcontroller, using embedded cryptographic libraries such as AES and SHA256.

But before diving into encryption, transport protocols, REST interfaces, and DevOps pipelines, we do something simple.
We make a **LED blink**.

And no, this is not a joke.

Blinking a LED, done right, means:
- abstracting hardware with HAL (Hardware Abstraction Layer),
- configuring peripherals without blocking the CPU,
- avoiding busy-waiting (`delay()`), and using `SysTick` instead,
- understanding what is generated by the IDE and what is under our control,
- reflecting on modularity, reusability, and atomicity — yes, even for a GPIO toggle.

> Engineering is not about blinking LEDs.
> It’s about knowing *why* the LED blinks, and doing so without wasting cycles, power or dignity.

This report documents every step of the project and not just the code itself but every reasoned design choice behind it.
Because in software engineering, **code without rationale is just copy-paste**.



# 2. Git Project Structure

The project is composed of **two separate repositories**, both part of the official GitHub organization for the Software Engineering course:

- [`code`](https://github.com/unibo-dtm-se-2223-SecureSensorNode/code): contains all source code, both firmware (C for STM32) and server-side components (Python).
- [`report`](https://github.com/unibo-dtm-se-2223-SecureSensorNode/report): contains this very report, written in Markdown.

This structure reflects a clean **separation of concerns**: the code evolves and is versioned independently from the documentation, which follows its own release cycle.

### 2.1 `code` Repository Structure

The `code` repository is organized as follows:

SecureSensorNode/
├── client/
│ └── firmware/ ← STM32CubeIDE project for Nucleo board (written in C using HAL)
├── server/ ← Microservice in Python: UART receiver + REST API
├── automation/ ← Bash scripts, Makefiles, CI configs (optional)
├── test/ ← Integration tests (TBD)
├── security/ ← Keys, crypto configs, protocol notes (TBD)
├── README.md
└── LICENSE


This layout is not accidental. It is designed to maximize:

- **modularity** (clear directory per component),
- **traceability** (Git-friendly layout, one concern per folder),
- **atomicity** (each module can be developed, tested, and versioned independently).

The use of Git is not limited to versioning — it is used to structure the entire development lifecycle:

- `README.md` describes the purpose and usage of the system.
- Commits follow a clean informative style (`feat`, `fix`, `doc`, `refactor`).
- Future additions may include GitHub Actions for CI/CD simulation and automated testing.

Every action — from toggling a GPIO to creating a REST endpoint — is tracked, justified, and versioned.



# 3. The Client — Engineering a Blinking LED

Before dealing with cryptography, REST APIs, and inter-device protocols, we start by making something blink.
But we do it **with intention, precision, and engineering awareness**.

The client is based on an **STM32 Nucleo-F401RE** board. Using **STM32CubeIDE** , we configure pin `PA5` — connected to the onboard green LED — and make it toggle every two seconds using the **SysTick** hardware timer.
This task may appear simple, but it provides a practical opportunity to explore and apply concepts such as **abstraction**, **non-blocking logic**, **hardware/software layering**, and **toolchain automation** — all central topics in modern **software engineering**.


## 3.1 HAL Abstraction and Custom Naming

Thanks to STM32CubeIDE’s graphical configurator, we selected pin `PA5` and renamed it `Green_Led`. This single action:

- configured the GPIO pin as a digital output,
- generated symbolic macros:

```c
  #define Green_Led_Pin GPIO_PIN_5
  #define Green_Led_GPIO_Port GPIOA
```

-allowed us to toggle the pin cleanly with:

 `HAL_GPIO_TogglePin(Green_Led_GPIO_Port, Green_Led_Pin);`

In just two clicks and one function call, the LED toggles.

This reflects the principle of abstraction, a recurring concept in modern software engineering methodologies. HAL encapsulates hardware interaction into modular APIs, aligning with agile development practices where prototyping speed and modular design are crucial.


## 3.2 HAL vs. Bare-Metal Equivalent

The HAL (Hardware Abstraction Layer) library is an embedded software layer developed by ST for STM32 microcontrollers. It aims to maximize portability across STM32 products by
providing a consistent API. HAL functions, such as HAL_GPIO_TogglePin(), encapsulate multiple low-level operations into a single call, making it easy to perform tasks like toggling
a pin.
However, HAL functions are not always interrupt-safe, and in some cases, they offer limited step-by-step control compared to direct register manipulation. This makes HAL convenient
and easy to read, but not atomic.
For fine-grained control—such as precise ISR timing, low-level synchronization, or performance tuning—it is often necessary to resort to CMSIS or direct register manipulation.

To understand the engineering value of HAL, we reproduce the same LED blinking routine using bare-metal code, based on CMSIS and direct register-level access (commonly referred to
as LL Drivers, or Lower Layer Drivers):

*// 1. Enable GPIOA clock (bit 0 in AHB1ENR)*
`RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;`

*// 2. Configure PA5 as general-purpose output*
```GPIOA->MODER &= ~(0x3 << (5 * 2));   // Clear bits
GPIOA->MODER |=  (0x1 << (5 * 2));   // Set mode to '01' (output)
```

*// 3. Set output type to push-pull*
`GPIOA->OTYPER &= ~(0x1 << 5);`

*// 4. Set output speed to low*
`GPIOA->OSPEEDR &= ~(0x3 << (5 * 2));`

*// 5. Disable pull-up/pull-down*
`GPIOA->PUPDR &= ~(0x3 << (5 * 2));`

*// 6. Toggle PA5 by XOR on the Output Data Register*
`GPIOA->ODR ^= (1 << 5);`

*// 7. Optional delay (for visibility, not recommended in production)*
`for (volatile int i = 0; i < 100000; i++);`

This implementation provides full control and deterministic behavior, but:
- is tightly coupled to the hardware,
- requires detailed knowledge of STM32 hardware design (registers in particular),
- lacks portability and modularity.

This emphasizes some of the core software engineering trade-offs: abstraction vs control, portability vs performance, convenience vs atomicity.


## 3.3 STM32CubeIDE: a powerful abstraction tool for embedded engineers

In this project we use STM32CubeIDE, the official development environment provided by STMicroelectronics. This IDE integrates a full toolchain for STM32 development, including:
- a graphical configuration interface,
- built-in compiler and linker (via `arm-none-eabi-gcc`),
- integration with HAL (Hardware Abstraction Layer) and LL (Low Level) libraries,
- debugging support via ST-Link.

STM32CubeIDE is not mandatory to develop on STM32 platforms, but offers huge benefits in terms of productivity and consistency. More importantly, it supports both HAL and LL (more granular control) libraries, depending on the needs of the engineer.
In our case, we opted for HAL as a deliberate choice: engineers are not paid to reinvent the wheel, but to master it and exploit it properly.

When a new project is created, STM32CubeIDE includes a set of precompiled libraries, provided by the vendors (ST and ARM). These are copied into the project structure but are not dynamically generated by the tool:

-**Drivers/STM32F4xx_HAL_Driver/** This folder contains the High-level drivers (HAL) provided by ST, designed to abstract hardware complexity (i.e. GPIO, USART, RCC, etc.)
-**Drivers/CMSIS/** This folder contains ARM’s Cortex Microcontroller Software Interface Standard (CMSIS) with core definitions, registers, NVIC setup, system startup support, etc. ** HAL itself is built on top of CMSIS** so this folder is mandatory even if we choose to develop with HAL.

These libraries provide portability and readability, and are used across thousands of embedded projects — without modification.

After choose the target microcontroller, peripherals configured graphically, pinout, the clock tree setup and other tips, STM32CubeIDE builds a number of critical dinamically-generated files.

Key generated files include:

| File                      | Role                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `main.c`, `main.h`        | Entry point and main application loop                        |
| `system_stm32f4xx.c`      | System clock setup, oscillator configuration                 |
| `stm32f4xx_it.c`          | Default **interrupt handlers** (including `SysTick_Handler`) |
| `startup_stm32f401retx.s` | Startup assembly file: **vector table**, reset handler       |
| `STM32F401RETx_FLASH.ld`  | **Linker script**: defines flash and RAM regions             |

Without the automation provided by this powerful IDE, the engineer would need to manually initialize the stack pointer, write the vector table in assembly, configure the reset handler,
define RAM and Flash regions using a linker script, write all clock tree setup code from scratch (HSI, PLL, prescalers) and implement HAL’s system tick via direct CMSIS calls.
This means hundreds of lines of fragile code that are error-prone and time-consuming.

This abstraction process is not just "comfort", but an engineering design decision. It allows the developer to focus on system logic, interaction, and optimization, instead of wasting
effort on boilerplate.
Using STM32CubeIDE and HAL supports important Software Engineering principles:
- abstraction: hide hardware complexity while exposing well-documented interfaces,
- component reuse: modular libraries that reduce duplication and improve maintainability,
- modular design: code organization that reflects separation of concerns and layering.

If needed, we can always go lower (LL or CMSIS) — but HAL lets us go faster, safer, and with cleaner code.

STM32CubeIDE promotes a DevOps-friendly development flow even in embedded systems, thanks to:
- deterministic project structure: every CubeIDE project has a known, reproducible format, suitable for versioning and integration in CI pipelines,
- makefile-based build system: under the hood, CubeIDE invokes GNU Make, allowing us to replicate the build process via CLI without the IDE,
- automated code generation: graphical configuration becomes source code, ensuring traceability and eliminating manual errors,
- easy integration with Git: every relevant file (except build artifacts) can be version-controlled, tagged, and reviewed.

This aligns with core DevOps practices like:
- infrastructure as Code (our .ioc file is literally "Hardware as Code"),
- continuous Integration (automated builds with tools like GitHub Actions or GitLab CI),
- test Automation (possible via unit testing on mock drivers or hardware-in-the-loop).

In short, HAL + CubeIDE allows embedded systems to benefit from the same agile and automated workflows used in web or cloud development — a key principle of modern Software Engineering.


## 3.4 Progressive Refinement of LED Blinking Logic

Embedded systems are not about blinking LEDs — but blinking LEDs properly reveals the mindset of the engineer behind the system. To demonstrate the design trade-offs behind embedded
control flow, we developed three progressive versions of a firmware component whose only task is to toggle an onboard LED at regular intervals (one second on, one second off).
Each version was committed, tested, and tagged in Git, where the evolution is visible.


### 3.4.1 Version 1 – The "Blocking Delay" (Tag: `v1`)

The code is composed of a `HAL_GPIO_TogglePin` instruction immediately followed by a blocking `HAL_Delay()` call, both placed inside the infinite superloop (`while(1)`) in the main.c 
file. 

```c
while (1)
{
  HAL_GPIO_TogglePin(Green_Led_GPIO_Port, Green_Led_Pin);
  HAL_Delay(1000);
}
```

This naive approach uses `HAL_Delay()`, which puts the CPU to sleep for the specified time. During that time,**no other task can execute**: no sensor can be read, no UART interrupt
can be serviced, no logic can progress. This approach is equivalent to putting the system in a coma between LED toggles.

(only) Problems:
- blocks the system entirely (no multitasking),
- power consumption remains constant (no low-power entry),
- CPU usage: 0% useful, 100% wasted.

This version was committed and tagged as:
`git tag v1` .


### 3.4.2 Version 2 – The "Polling Strategy" (Tag: v2)

Here, `HAL_Delay()` is removed and replaced with non-blocking logic using `HAL_GetTick()`.
This version avoids freezing the CPU, allowing additional tasks to be inserted in the main loop.

```c
uint32_t lastTick = 0;

while (1)
{
  uint32_t now = HAL_GetTick();
  if ((now - lastTick) >= 1000)
  {
    HAL_GPIO_TogglePin(Green_Led_GPIO_Port, Green_Led_Pin);
    lastTick = now;
  }

    *// Other tasks can be placed here*
}
```

However, it still involves constant polling, i.e. checking a condition over and over, which wastes CPU cycles and power.

Improvements:
- no more blocking,
- allows multitasking inside the main loop.

Still problematic:
- busy-waiting is energy inefficient,
- main loop complexity grows with tasks,
- inefficient in low-power applications.

This version was committed and tagged as:
`git tag v2` .

According with the organization of the project, modifies v1 and v2 take place in ~/projects/SecureSensorNode/client/firmware/Core/Src/main.c .


### 3.4.3 Version 3 – Event-driven via SysTick Interrupt (Tag: v3)

This final version consists of a few lines of code inserted **inside** the SysTick_Handler() function defined in the stm32f4xx_it.c file (~/projects/SecureSensorNode/client/firmware/Core/Src/stm32f4xx_it.c), 
rather than in the superloop of main.c.
This **interrupt-driven** approach detaches the LED blinking logic from the main application flow. It makes the system **fully event-based**, eliminating the need for polling or blocking instructions.

```c
void SysTick_Handler(void)
{
  HAL_IncTick(); // Maintains HAL timebase

  static uint32_t count = 0;
  if (++count >= 2000)
  {
    HAL_GPIO_TogglePin(Green_Led_GPIO_Port, Green_Led_Pin);
    count = 0;
  }
}
```

The **SysTick interrupt** is automatically triggered every 1 ms by the ARM Cortex-M core. We increment a static counter each time the interrupt is fired and toggle the LED every 
2000 ms. The static keyword ensures that the variable count retains its value across multiple executions of the handler.

From a software engineering perspective, this change:
- Frees the while(1) loop, which can now be left completely empty,
- Turns the firmware into an event-driven architecture,
- Improves modularity, allowing the CPU to react only when needed.

This empty superloop could now act as an idle loop, a typical feature in embedded systems. In a more advanced scenario, it could even be combined with low-power features, such as:
- the __WFI() ("Wait For Interrupt") instruction, which halts the CPU until the next interrupt,
- or ** Sleep, Stop, or Standby modes**, available on STM32 microcontrollers.

Low-power techniques are not implemented at this stage, but will be discussed in detail in later sections, when real sensor acquisition and data transmission are integrated. 
At that point, reducing CPU activity and energy footprint will become essential.

Key benefits:
- no CPU cycles wasted on polling,
- full responsiveness and multitasking,
- excellent energy profile,
- aligns with event-driven design patterns in embedded and real-time systems.

Tagged as:
`git tag v3` .


## 3.5 Git Versioning of Firmware Evolution

To ensure traceability and document the evolution of the LED blinking logic, each version was committed and tagged in the Git repository. The progression was implemented within a
single STM32 project, and version control was used to capture each stage of refinement.

The files involved are:
- main.c (for versions 1 and 2),
- stm32f4xx_it.c (for version 3).

Git commands used to commit and tag the versions:

### Version 1 – HAL_Delay (blocking)
```bash
git add client/firmware/Core/Src/main.c
git commit -m "v1: Blocking LED blinking with HAL_Delay()"
git tag v1
git push
git push origin v1
```

### Version 2 – HAL_GetTick (polling)
```bash
git add client/firmware/Core/Src/main.c
git commit -m "v2: Non-blocking LED blinking with HAL_GetTick()"
git tag v2
git push
git push origin v2
```

### Version 3 – SysTick interrupt (event-driven)
```bash
git add client/firmware/Core/Src/stm32f4xx_it.c
git commit -m "v3: Event-driven LED blinking via SysTick_Handler"
git tag v3
git push
git push origin v3
```

Each tagged version is visible in the remote repository and can be restored or inspected independently.



## 3.6 Manual Flashing via Command Line

About flashing, instead of using the IDE’s built-in flashing system, we performed firmware upload via command line:

```bash
arm-none-eabi-objcopy -O binary BlinkHAL.elf BlinkHAL.bin
st-flash write BlinkHAL.bin 0x08000000
```

Why did we choose the command line?
- Transparent output: the CLI tools display each operation performed, allowing us to clearly see the memory mapping, flashing progress, and any errors,
- Portability: this method works in headless environments (e.g., remote machines accessed via SSH) and is independent of GUI tools,
- Reproducibility: the process can be scripted and reused, facilitating version-controlled deployment pipelines,
- Logging clarity: unlike IDEs that may abstract away low-level messages, st-flash outputs precise logs, which are helpful for debugging,
- DevOps alignment: this manual process matches the mindset of automation and repeatability, key themes in modern DevOps and agile software engineering practices.



## 3.7 DevOps-aligned Automation: Building and Flashing via Shell Script

Automation and CI/CD pipelines are key pillars of DevOps engineering. Even in embedded development, adopting these practices improves consistency, testing, and deployment speed.
In line with theese principles, we created a minimal shell script to handle firmware building and flashing from terminal.

This allows:
- fast development and testing cycles without relying on the IDE,
- integration in CI/CD pipelines or remote/headless environments,
- complete visibility over the build process.

The script, located at `automation/flash.sh`, performs the following steps:
1. Cleans the build directory.
2. Compiles the firmware using `make`.
3. Converts the `.elf` output to a `.bin` binary using `arm-none-eabi-objcopy`.
4. Uploads the binary to the STM32 board via `st-flash`.

This workflow was tested on Ubuntu 22.04 using ST-Link v2.

### Script: `flash.sh`

```bash
#!/bin/bash

# Path to the firmware build directory
BUILD_DIR=client/firmware/Debug
PROJECT_NAME=BlinkHAL

echo "[1] Building the project..."
make -C $BUILD_DIR

echo "[2] Creating binary image..."
arm-none-eabi-objcopy -O binary $BUILD_DIR/${PROJECT_NAME}.elf $BUILD_DIR/${PROJECT_NAME}.bin

echo "[3] Flashing firmware via st-flash..."
st-flash write $BUILD_DIR/${PROJECT_NAME}.bin 0x08000000

echo "Done!"
```

To make sure the script is executable:
`chmod +x automation/flash.sh`

Now it is possible to flash the firmware with:
`./automation/flash.sh`


